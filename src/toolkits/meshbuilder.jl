#==========================================================================================+
|           MaterialPointSolver.jl: High-performance MPM Solver for Geomechanics           |
+------------------------------------------------------------------------------------------+
|  File Name  : meshbuilder.jl                                                             |
|  Description: Generate structured mesh in 2&3D space                                     |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : meshbuilder()                                                              |
|               getparticle()                                                              |
+==========================================================================================#

export meshbuilder
export getparticle

function meshbuilder(x::AbstractRange, y::AbstractRange)
    x_tmp = repeat(x', length(y), 1) |> vec
    y_tmp = repeat(y , 1, length(x)) |> vec
    return hcat(x_tmp, y_tmp)
end

function meshbuilder(x::AbstractRange, y::AbstractRange, z::AbstractRange)
    vx      = x |> collect
    vy      = y |> collect
    vz      = z |> collect
    m, n, o = length(vy), length(vx), length(vz)
    vx      = reshape(vx, 1, n, 1)
    vy      = reshape(vy, m, 1, 1)
    vz      = reshape(vz, 1, 1, o)
    om      = ones(Int, m)
    on      = ones(Int, n)
    oo      = ones(Int, o)
    x_tmp   = vec(vx[om, :, oo])
    y_tmp   = vec(vy[:, on, oo])
    z_tmp   = vec(vz[om, on, :])
    return hcat(x_tmp, y_tmp, z_tmp)
end

"""
    sort_polygon_ccw(polygon)

Description:
---
Sort the polygon vertices in counter-clockwise order.
(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function sort_polygon_ccw(polygon)
    centroid = sum(polygon, dims=1) / size(polygon, 1)
    angles = map(p -> atan(p[2] - centroid[2], p[1] - centroid[1]), eachrow(polygon))
    sorted_indices = sortperm(angles)
    return polygon[sorted_indices, :]
end

"""
    is_point_in_polygon(px, py, polygon)

Description:
---
Determine whether a point is inside a polygon.
(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function is_point_in_polygon(px, py, polygon)
    n = size(polygon, 1)
    winding_number = 0
    @inbounds for i in 1:n
        p11 = polygon[i, 1]
        p12 = polygon[i, 2]
        p21 = polygon[mod1(i + 1, n), 1]
        p22 = polygon[mod1(i + 1, n), 2]
        if p12 ≤ py && p22 > py && (p21 - p11) * (py - p12) > (px - p11) * (p22 - p12)
            winding_number += 1
        elseif p12 > py && p22 ≤ py && (p21 - p11) * (py - p12) < (px - p11) * (p22 - p12)
            winding_number -= 1
        end
    end
    return winding_number != 0
end

"""
    getparticle(domain, lp; sort::Bool=true)

Description:
---
Get particles inside a domain.
(This function is generated by ChatGPT 4o - 2024.10.10)
"""
@views function getparticle(domain, lp; sort::Bool=true)

    x_min = minimum(domain[:, 1])
    x_max = maximum(domain[:, 1])
    y_min = minimum(domain[:, 2])
    y_max = maximum(domain[:, 2])

    offsetx = (x_max - x_min) * 0.2
    offsety = (y_max - y_min) * 0.2

    x_min -= offsetx
    x_max += offsetx
    y_min -= offsety
    y_max += offsety

    mesh = meshbuilder(x_min:lp:x_max, y_min:lp:y_max)

    pts = size(mesh, 1)

    # 1. 对domain逆时针排序
    sorted_domain = sort == true ? sort_polygon_ccw(domain) : domain

    rst = BitVector(undef, pts)  # 使用BitVector来减少内存占用
    @inbounds Threads.@threads for i in 1:pts
        px = mesh[i, 1]
        py = mesh[i, 2]
        rst[i] = is_point_in_polygon(px, py, sorted_domain)
    end

    return copy(mesh[findall(rst), :])  # 使用BitVector时，直接findall即可
end

"""
    gmsh_mesh3D(geo_path::String, size_min, size_max)

Description:
---
Generate 3D mesh using Gmsh.
"""
@views function gmsh_mesh3D(geo_path::String, size_min, size_max)
    gmsh.initialize()   # initialize Gmsh
    gmsh.open(geo_path) # load .geo file generated by Gmsh GUI/Script
    # set mesh options
    gmsh.option.setNumber("Mesh.Algorithm3D", 1) # set mesh algorithm as Delaunay（1）or Frontal-Delaunay（4）
    gmsh.option.setNumber("Mesh.CharacteristicLengthMin", size_min)  # minimum size of mesh
    gmsh.option.setNumber("Mesh.CharacteristicLengthMax", size_max)  # maximum size of mesh
    gmsh.option.setNumber("Mesh.ElementOrder", 1) # set element order as 1 (linear tetrahedra）
    gmsh.option.setNumber("Mesh.RecombineAll", 0)  # to enforce the generation of tetrahedral
    # generate mesh
    gmsh.model.mesh.generate(3) # generate 3D mesh
    _, node_coords, _ = gmsh.model.mesh.getNodes() # get all nodes' coordinates
    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements() # get all elements' information
    # search the type index of tetrahedra elements
    tet_type = 4  # linear tetrahedra type index，（10 is for second-order tetrahedron）
    tet_index = findfirst(==(tet_type), elem_types)
    tet_index === nothing && error("Cannot find tetrahedra elements")
    tet_node_tags = elem_node_tags[tet_index] # extract the node tags of tetrahedra
    # finalize Gmsh
    gmsh.finalize()
    # reshape nodes and elements
    n_nodes = length(node_coords) ÷ 3
    node = Matrix{Float64}(undef, n_nodes, 3)
    for i in 1:n_nodes
        node[i, 1] = node_coords[3i-2] # x
        node[i, 2] = node_coords[3i-1] # y
        node[i, 3] = node_coords[3i  ] # z
    end
    n_tetrahedra = length(tet_node_tags) ÷ 4  # 4 nodes in one tetrahedron
    tetrahedra = Matrix{Int}(undef, n_tetrahedra, 4)
    for i in 1:n_tetrahedra
        tetrahedra[i, :] = tet_node_tags[(4i-3):(4i)]
    end
    return node, tetrahedra
end

"""
    pts_in_polyhedron!(pts, node, tet, results)

Description:
---
Check if the point set is inside a polyhedron.
"""
@kernel inbounds = true function pts_in_polyhedron!(pts, node, tet, results)
    i = @index(Global)
    if i ≤ size(pts, 1)
        T2   = eltype(pts)
        tets = size(tet, 1)
        inv6 = inv(T2(6.0))
        x, y, z = pts[i, 1], pts[i, 2], pts[i, 3]  # 获取当前粒子的坐标
        for j in 1:tets
            # 获取四面体顶点的坐标索引
            tet_aid, tet_bid, tet_cid, tet_did = tet[j, 1], tet[j, 2], tet[j, 3], tet[j, 4]
            ax, ay, az = node[tet_aid, 1], node[tet_aid, 2], node[tet_aid, 3]
            bx, by, bz = node[tet_bid, 1], node[tet_bid, 2], node[tet_bid, 3]
            cx, cy, cz = node[tet_cid, 1], node[tet_cid, 2], node[tet_cid, 3]
            dx, dy, dz = node[tet_did, 1], node[tet_did, 2], node[tet_did, 3]

            min_x = min(ax, bx, cx, dx)
            max_x = max(ax, bx, cx, dx)
            min_y = min(ay, by, cy, dy)
            max_y = max(ay, by, cy, dy)
            min_z = min(az, bz, cz, dz)
            max_z = max(az, bz, cz, dz)
            if x < min_x || x > max_x || y < min_y || y > max_y || z < min_z || z > max_z
                continue  # 粒子不在该四面体的包围盒内，跳过
            end

            # 计算原四面体的体积
            v0x, v0y, v0z = bx - ax, by - ay, bz - az
            v1x, v1y, v1z = cx - ax, cy - ay, cz - az
            v2x, v2y, v2z = dx - ax, dy - ay, dz - az
            V0 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6

            # 计算包含点 P 和每个面构成的四个四面体的体积
            # 四面体 P, B, C, D
            v0x, v0y, v0z = bx - x, by - y, bz - z
            v1x, v1y, v1z = cx - x, cy - y, cz - z
            v2x, v2y, v2z = dx - x, dy - y, dz - z
            V1 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6

            # 四面体 A, P, C, D
            v0x, v0y, v0z = ax - x, ay - y, az - z
            v1x, v1y, v1z = cx - x, cy - y, cz - z
            v2x, v2y, v2z = dx - x, dy - y, dz - z
            V2 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6

            # 四面体 A, B, P, D
            v0x, v0y, v0z = ax - x, ay - y, az - z
            v1x, v1y, v1z = bx - x, by - y, bz - z
            v2x, v2y, v2z = dx - x, dy - y, dz - z
            V3 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6

            # 四面体 A, B, C, P
            v0x, v0y, v0z = ax - x, ay - y, az - z
            v1x, v1y, v1z = bx - x, by - y, bz - z
            v2x, v2y, v2z = cx - x, cy - y, cz - z
            V4 = abs((v0x * (v1y * v2z - v1z * v2y) - 
                      v0y * (v1x * v2z - v1z * v2x) + 
                      v0z * (v1x * v2y - v1y * v2x))) * inv6

            # 如果四个体积之和等于原四面体的体积，则点在四面体内
            if abs(V0 - (V1 + V2 + V3 + V4)) < eps(T2)
                results[i] = 1  # 点位于四面体内
                break  # 如果在某个四面体内，提前结束循环
            end
        end
    end
end

function getparticle(geo_path::String, size_min, size_max, lp, ::Val{:CPU})
    local node, tet
    @suppress node, tet = gmsh_mesh3D(geo_path, size_min, size_max)
    # terminal info
    @info """Gmsh results
    number of nodes     : $(size(node, 1))
    number of tetrahedra: $(size(tet, 1))
    """
    # get bounding box for particles
    min_x, max_x = minimum(node[:, 1]), maximum(node[:, 1])
    min_y, max_y = minimum(node[:, 2]), maximum(node[:, 2])
    min_z, max_z = minimum(node[:, 3]), maximum(node[:, 3])
    offsetx = (max_x - min_x) * 0.2
    offsety = (max_y - min_y) * 0.2
    offsetz = (max_z - min_z) * 0.2
    min_x -= offsetx
    max_x += offsetx
    min_y -= offsety
    max_y += offsety
    min_z -= offsetz
    max_z += offsetz
    # generate structured particles
    pts = meshbuilder(min_x:lp:max_x, min_y:lp:max_y, min_z:lp:max_z)
    pts_num = size(pts, 1)
    results = Vector{Bool}(zeros(pts_num))
    pts_in_polyhedron!(CPU())(ndrange=pts_num, pts, node, tet, results)
    return copy(pts[findall(i -> results[i], 1:pts_num), :])
end