#==========================================================================================+
|           MaterialPointSolver.jl: High-performance MPM Solver for Geomechanics           |
+------------------------------------------------------------------------------------------+
|  File Name  : meshbuilder.jl                                                             |
|  Description: Generate structured mesh in 2&3D space                                     |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : meshbuilder()                                                              |
|               getparticle()                                                              |
+==========================================================================================#

export meshbuilder
export getparticle

function meshbuilder(x::AbstractRange, y::AbstractRange)
    x_tmp = repeat(x', length(y), 1) |> vec
    y_tmp = repeat(y , 1, length(x)) |> vec
    return x_tmp, y_tmp
end

function meshbuilder(x::AbstractRange, y::AbstractRange, z::AbstractRange)
    vx      = x |> collect
    vy      = y |> collect
    vz      = z |> collect
    m, n, o = length(vy), length(vx), length(vz)
    vx      = reshape(vx, 1, n, 1)
    vy      = reshape(vy, m, 1, 1)
    vz      = reshape(vz, 1, 1, o)
    om      = ones(Int, m)
    on      = ones(Int, n)
    oo      = ones(Int, o)
    x_tmp   = vec(vx[om, :, oo])
    y_tmp   = vec(vy[:, on, oo])
    z_tmp   = vec(vz[om, on, :])
    return x_tmp, y_tmp, z_tmp
end

"""
    sort_polygon_ccw(polygon)

Description:
---
Sort the polygon vertices in counter-clockwise order.
(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function sort_polygon_ccw(polygon)
    centroid = sum(polygon, dims=1) / size(polygon, 1)
    angles = map(p -> atan(p[2] - centroid[2], p[1] - centroid[1]), eachrow(polygon))
    sorted_indices = sortperm(angles)
    return polygon[sorted_indices, :]
end

"""
    is_point_in_polygon(px, py, polygon)

Description:
---
Determine whether a point is inside a polygon.
(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function is_point_in_polygon(px, py, polygon)
    n = size(polygon, 1)
    winding_number = 0
    @inbounds for i in 1:n
        p11 = polygon[i, 1]
        p12 = polygon[i, 2]
        p21 = polygon[mod1(i + 1, n), 1]
        p22 = polygon[mod1(i + 1, n), 2]
        if p12 ≤ py && p22 > py && (p21 - p11) * (py - p12) > (px - p11) * (p22 - p12)
            winding_number += 1
        elseif p12 > py && p22 ≤ py && (p21 - p11) * (py - p12) < (px - p11) * (p22 - p12)
            winding_number -= 1
        end
    end
    return winding_number != 0
end

"""
    getparticle(domain, lp; sort::Bool=true)

Description:
---
Get particles inside a domain.
(This function is generated by ChatGPT 4o - 2024.10.10)
"""
@views function getparticle(domain, lp; sort::Bool=true)

    x_min = minimum(domain[:, 1])
    x_max = maximum(domain[:, 1])
    y_min = minimum(domain[:, 2])
    y_max = maximum(domain[:, 2])

    offsetx = (x_max - x_min) * 0.2
    offsety = (y_max - y_min) * 0.2

    x_min -= offsetx
    x_max += offsetx
    y_min -= offsety
    y_max += offsety

    x_, y_ = meshbuilder(x_min:lp:x_max, y_min:lp:y_max)
    mesh = hcat(x_, y_)

    pts = size(mesh, 1)

    # 1. 对domain逆时针排序
    sorted_domain = sort == true ? sort_polygon_ccw(domain) : domain

    rst = BitVector(undef, pts)  # 使用BitVector来减少内存占用
    @inbounds Threads.@threads for i in 1:pts
        px = mesh[i, 1]
        py = mesh[i, 2]
        rst[i] = is_point_in_polygon(px, py, sorted_domain)
    end

    return copy(mesh[findall(rst), :])  # 使用BitVector时，直接findall即可
end